(* Walking on a Graph

   We can think of function `g` of type `'a -> 'a -> bool` as a graph
   in which there is an edge between `i` and `j` exactly when `g i j`
   is `true`.

   A function `p` of type `'a -> 'a` generates a list of values by
   repeated application from a given starting point.  We will call
   this a POTENTIAL PATH and we will call `p` a PATH GENERATOR. For
   example, the list `[x; p x; p (p x)]` is potential path of length 2
   starting at `x`

   A potential path is VALID for a given graph `g` if every pair of
   adjacent elements forms an edge in `g`.  Continuing the above
   example, the potential path `[x; p x; p (p x)]` is valid for `g` if
   `g x (p x) && g (p x) (p (p x))` is `true`.

   Implement the function `walks` which, given

     g : a graph (a function of type 'a -> 'a -> bool)
     len : an integer
     paths_starts : a list of (path generator, starting point) pairs

   returns the list of endpoints of all valid paths which have length
   `max 0 len` generated by each path generator on its associated
   starting point.

   The order of endpoints in the output should be consistent with the
   order of the starting points, even if some potential paths are
   dropped because they are not valid in `g`.

   You should use the functions `List.map` and `List.filter`.  It may
   also be useful to try to use the pipelining operator `|>`.

   Examples:
   let g1 (i : int) (j: int) = i < j && i <= 10 && j <= 10
   let g2 (i : int) (j: int) = i <= 10 && j <= 10

   let p1 i = i + 1
   let p2 i = i - 1
   let p3 i = i + 2

   let _ = assert (walks g1 0 [(p1, 0); (p2, 0); (p3, 0)] = [0;0;0])
   let _ = assert (walks g1 1 [(p1, 0); (p2, 0); (p3, 0)] = [1;2])
   let _ = assert (walks g1 3 [(p1, 0); (p2, 0); (p3, 0)] = [3;6])
   let _ = assert (walks g1 6 [(p1, 0); (p2, 0); (p3, 0)] = [6])
   let _ = assert (walks g2 2 [(p1, 3); (p2, 5); (p3, 3)] = [5; 3; 7])
   let _ = assert (walks g2 4 [(p1, -10); (p2, -20); (p3, 8)] = [-6; -24])
   let _ = assert (walks g2 6 [(p1, 5); (p2, 11); (p3, -10)] = [2])
*)

(* extracts the last element of a list *)
let rec endpoint path =
  match path with
  | [] -> assert false (* impossible if calling on a valid path *)
  | [x] -> x
  | _ :: xs -> endpoint xs

let walks
    (g : 'a -> 'a -> bool)
    (len : int)
    (paths_starts : (('a -> 'a) * 'a) list) : 'a list =
(* function that creates the path and keep creating until len = 0 *)
    let rec create path st len =
      match len with
      | 0 -> [st]
      | _ -> st :: create path (path st) (len - 1)
    in

(* checks if the path created is actually valid *)
    let rec valid path =
      match path with
      | [] -> true
      | [_] -> true
      |x :: (xs :: xss) -> g x xs && valid (xs :: xss)
    in

(* map create function to create all possible paths and then filter out only valid paths *)
  paths_starts
    |> List.map (fun (p, st) -> create p st len)
    |> List.filter valid
(* created special endpoint function to extract last element of list (where the endpoint is) *)
(* can't just do list.rev as the lists are in a list *)
    |> List.map endpoint